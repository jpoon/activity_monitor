#include <termios.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <stdint.h>
#include <fcntl.h>
#include <sys/signal.h>
#include <sys/types.h>
#include <errno.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netdb.h>
#include <stdlib.h>

#define MAX_SLIP_BUF    1024

// SLIP control sequences
#define ESC         219
#define END         192
#define START       193

enum mode_t {
    ascii,
    slip
};

void server_tx(char* buf, uint8_t size);
void print_usage ();
void server_open(unsigned int port);
void server_non_blocking_rx (int fd);
void slip_rx (int fd);
void slip_tx (int fd, uint8_t * buf, int size);

int sock, fromlen, replylen;
struct sockaddr_in client;
uint8_t buf[1024];
int got_connection;
int debug;

int main (int argc, char *argv[])
{
    char devicename[80];
    int fd, res;
    uint8_t c;
    struct termios oldtio, newtio;
    int start_flag;

    got_connection = 0;

    mode_t mode = ascii;

    long BAUD = B115200;
    long DATABITS = CS8;
    long STOPBITS = 0;      // STOPBITS = CSTOPB;
    long PARITYON = 0;      // PARITYON = PARENB;
    long PARITY = 0;             // PARITY = PARODD;
    
    unsigned int portNum = 4000;
    sprintf(devicename, "/dev/ttyUSB0");
 
    int opt;
    while ((opt = getopt (argc, argv, "hdc:p:")) != -1) {
        switch (opt) {
            case 'h':
                print_usage();
                break;
            case 'd':
                debug = 1;
                break;
            case 'c':
                strcpy(&devicename[0],optarg);
                break;
            case 'p':
                portNum = atoi(optarg);
                break;
            case ':':
                fprintf(stderr, "Option -%c requires an operand\n", optopt);
                break;
           case '?':
                fprintf (stderr, "Unknown option `-%c'.\n", optopt);
                return 1;
        }
    }

    // open the device to be non-blocking (read will return immediately)
    fd = open (devicename, O_RDWR | O_NOCTTY | O_NONBLOCK);
    if (fd < 0) {
        perror (devicename);
        exit (-1);
    }

    if(debug) {
        printf ("opened: %s\n", devicename);
    }

    // save current port setting
    tcgetattr (fd, &oldtio);

    // set new port settings for canonical input processing
    newtio.c_cflag =  BAUD | DATABITS | STOPBITS | PARITYON | PARITY | CLOCAL | CREAD;
    newtio.c_iflag = IGNPAR;
    newtio.c_oflag = 0;
    newtio.c_lflag = 0;         //ICANON;
    newtio.c_cc[VMIN] = 1;
    newtio.c_cc[VTIME] = 0;
    tcflush (fd, TCIFLUSH);
    tcsetattr (fd, TCSANOW, &newtio);

    server_open(portNum);
    start_flag = 0;
    while (1) {
        server_non_blocking_rx(fd);
        res = read (fd, &c, 1);
        if (res > 0) {
            if (c == START) {
                mode = slip;
            }
            if (mode == slip) {
                slip_rx (fd);
                mode = ascii;
            }
            if (mode == ascii) {
                if(debug) printf ("%c", c);
            }
        } else {
            usleep(10000);
        }
    }
}

void slip_rx (int fd)
{
    char slip_buf[MAX_SLIP_BUF];
    uint8_t c;
    int i;

    int received = 0;
    mode_t mode = slip;
    while (mode == slip) {
        // get a character to process
        int res = read (fd, &c, 1);
        if (res > 0) {
            // handle bytestuffing if necessary
            switch (c) {

            // if it's an END character then we're done with the packet
            case END:
                // a minor optimization: if there is no data in the packet, ignore it. 
                // This is meant to avoid bothering IP with all the empty packets 
                // generated by the duplicate END characters which are in turn sent 
                // to try to detect line noise.
                if (received) {
                    unsigned int size = slip_buf[0];
                    if (received - 2 != size) {
                        if(debug) printf("slip: rx size mismatch %d vs %d\n", received - 2, size);
                        mode = ascii;
                        break;
                    }

                    unsigned int checksum = 0;
                    for (i = 1; i < received - 1; i++) {
                        checksum += slip_buf[i];
                    }
                    checksum &= 0x7F;
                    if (checksum != slip_buf[received - 1]) {
                        if(debug) printf("slip: rx checksum error %d != %d...\n", checksum, slip_buf[received - 1]);
                        mode = ascii;
                        break;
                    }
                    server_tx (&slip_buf[1], size);
                }

                mode = ascii;                
                break;

            // if it's the same code as an ESC character, wait and get another 
            // character and then figure out what to store in the packet based on that.
            case ESC:
                do {
                    res = read (fd, &c, 1);
                } while (res < 1);
                // if "c" is not one of these two, then we have a protocol violation.
                // The best bet seems to be to leave the byte alone and just stuff it 
                // into the packet
                switch (c) {
                    case END:
                        c = END;
                        break;
                    case ESC:
                        c = ESC;
                        break;
                }

            // here we fall into the default handler and let it store the character for us
            default:
                if (received < MAX_SLIP_BUF)
                    slip_buf[received++] = c;
            }
        }
    }
}

void server_open(unsigned int port)
{
    struct sockaddr_in server;

    got_connection = 0;
    sock = socket (AF_INET, SOCK_DGRAM, 0);
    // Non-blocking socket
    fcntl (sock, F_SETFL, O_NONBLOCK);
    if (sock < 0) {
        perror ("Opening socket");
    }
    bzero (&server, sizeof(server));
    server.sin_family = AF_INET;
    server.sin_addr.s_addr = INADDR_ANY;
    server.sin_port = htons (port);
    if (bind (sock, (struct sockaddr *) &server, sizeof(server)) < 0) {
        perror ("binding");
    }
    fromlen = sizeof (struct sockaddr_in);
    replylen = sizeof (struct sockaddr_in);
}

void server_non_blocking_rx (int fd)
{
    struct sockaddr_in from;

    int n = recvfrom (sock, buf, 1024, 0, (struct sockaddr *) &from, (socklen_t *) &fromlen);
    if (n > 0) {
        bcopy(&from,&client,sizeof(struct sockaddr));
        got_connection = 1;
        slip_tx (fd, buf, n);
    }
}

void slip_tx (int fd, uint8_t * buf, int size)
{
    int8_t c;

    // Make sure size is less than 128 so it doesn't act as a control message
    if (size > 128)
        return;

    uint8_t checksum = 0;
    // Send the start byte
    c = START;
    while(write (fd, &c, 1)<0) ;
    c = size;

    while(write (fd, &c, 1)<0) ;

    // Send payload and stuff bytes as needed
    for (int i = 0; i < size; i++) {
        if (buf[i] == END || buf[i] == ESC) {
            c = ESC;
            write (fd, &c, 1);
        }
        c = buf[i];
        while(write (fd, &c, 1)<0) ;
        checksum += buf[i];
    }

    // Make sure checksum is less than 128 so it doesn't act as a control message
    checksum &= 0x7f;
    // Send the end byte
    c = checksum;
    while(write (fd, &c, 1)<0) ;
    c = END;
    while(write (fd, &c, 1)<0) ;
}

void server_tx(char *buf, uint8_t size)
{
    if (got_connection != 0) {
        int n = sendto (sock, buf, size, 0, (struct sockaddr *) &client, replylen);

        if (n < 0)
            perror ("sendto");
    }
}


void print_usage ()
{
    printf("Usage: \n\
    ./SLIPstream [-h] [-d] [-c DEVICE] [-p SERVER PORT]\n");
    printf("Options: \n\
    -h \t Prints this message and exists\n\
    -d \t Turns on debugging. Shows SLIP packets and incoming datagrams\n\
    -c \t Device in which programming board is connected\n\
    -p \t Port on which to listen for connections\n");
    exit(-1);
}
